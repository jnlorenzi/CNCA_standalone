import os
import sys
import shutil
import argparse
from pathlib import Path
import json

"""

"""


def parseArguments():
    # Create argument parser
    parser = argparse.ArgumentParser(
        description='command line example: python aligner_preparator.py ~/Documents/SARS-cov2/table/genome/SARS-cov2-vs-nr/ ~/Documents/SARS-cov2/table/mafft/SARS-cov2-vs-nr_multiple_1_gl3/infile_mafft/ ~/Documents/SARS-cov2/table/mafft/SARS-cov2-vs-nr_multiple_1_gl3/outfile_mafft/ ~/Documents/SARS-cov2/table/mafft/SARS-cov2-vs-nr_multiple_1_gl3/logfile_mafft/ -s ~/Documents/SARS-cov2/table/identity/clustering/SARS-cov2-vs-nr_multiple/1_gl3_236-38.csv -m mafft')

    # Positional mandatory arguments
    parser.add_argument('-d', '--data_path',
                        help="absolute or relative path to the genome (nuc align) or cds (aa align) directory (generated by retrieve_genome.py)",
                        type=str)
    parser.add_argument('-i', '--aligner_infile_path',
                        help="absolute or relative path to the aligner infile directory (created)", type=str)
    parser.add_argument('-o', '--aligner_outfile_path',
                        help="absolute or relative path to the aligner outfile directory (created)", type=str)
    parser.add_argument('-s', '--sequence_filter_path', default='NA', help="path to the csv file with the sequence id to use)",
                        type=str)
    parser.add_argument('-m', '--method', default='clustal', const='clustal', nargs='?', choices=['clustal', 'mafft'],
                        help='global alignement method: clustal or mafft (default: %(default)s)')
    parser.add_argument('-th', '--tail_head', default='False', const='False', nargs='?', choices=['True', 'False'],
                        help='Inverse input sequences (default: %(default)s)')
    parser.add_argument('-t', '--data_type', choices=['nuc', 'aa'], help='Sequence type')

    parser.add_argument('-st', '--strategy')
    parser.add_argument('-gs', '--gapscore')
    parser.add_argument('-sm', '--scorematrix')
    parser.add_argument('-smn', '--scorematrixnuc',)
    parser.add_argument('-gop', '--gapopeningpenalty')
    parser.add_argument('-ov', '--offsetvalue')
    parser.add_argument('-nw', '--nwildcardorzerox')

    # Print version
    parser.add_argument("--version", action="version", version='%(prog)s - Version 2.3 - 27.10.2021')

    # Parse arguments
    args = parser.parse_args()
    return args


def load_fasta(fasta_file):
    with open(fasta_file, 'r') as infile:
        sequence = {}
        key = os.path.splitext(os.path.basename(fasta_file))[0]
        sequence[key] = []
        for line in infile:
            if line.startswith('>'):
                continue
            else:
                sequence[key].append(line.rstrip())
    sequence[key] = ''.join(sequence[key])
    return sequence


def multiple_nuc_alignment_infile_maker(fasta_file, path_aligner_infile, tail_head):
    os.makedirs(path_aligner_infile, exist_ok=True)
    name_clustal_infile = path_aligner_infile + '/multiple.fasta'
    if not Path(name_clustal_infile).is_file():
        with open(name_clustal_infile, 'w') as outfile:
            pass
    with open(name_clustal_infile, 'a') as outfile:
        with open(fasta_file, 'r') as fd:
            # Normal run, the sequence is unchanged
            if tail_head == 'False':
                shutil.copyfileobj(fd, outfile)
            # The sequence is reversed
            else:
                handler = []
                handler_name = ''
                for line in fd:
                    if line.startswith('>'):
                        handler_name = line
                    else:
                        handler.append(line.rstrip())
                handler = ''.join(handler)[::-1]
                outfile.write(handler_name)
                outfile.write('\n'.join([handler[i: i + 70] for i in range(0, len(handler), 70)]) + '\n')


def multiple_aa_alignment_infile_maker(seq_name, seq, path_infile, tail_head):
    os.makedirs(path_infile, exist_ok=True)
    name_infile = path_infile + '/multiple.fasta'
    if not Path(name_infile).is_file():
        with open(name_infile, 'w') as outfile:
            pass
    with open(name_infile, 'a') as outfile:
        outfile.write('>' + seq_name + '\n')
        # Normal run, the sequence is unchanged
        if tail_head == 'False':
            outfile.write('\n'.join([seq[i: i + 70] for i in range(0, len(seq), 70)]) + '\n')
        # The sequence is reversed
        else:
            outfile.write('\n'.join([seq[i: i + 70] for i in range(0, len(seq), 70)][::-1]) + '\n')


def check_mutliple_aligner_infile(path_aligner_infile):
    # Genome identifier must be unique
    list_id = []
    with open(path_aligner_infile, 'r') as infile:
        with open(path_aligner_infile + '.tmp', 'w') as outfile:
            for line in infile:
                if line.startswith('>'):
                    genome_id = line.split()[0]
                    id_count = 1
                    if genome_id in list_id:
                        while True:
                            if genome_id + '_c' + str(id_count) not in list_id:
                                break
                            else:
                                id_count += 1
                        list_id.append(genome_id + '_c' + str(id_count))
                        outfile.write(line.replace(genome_id, genome_id + '_c' + str(id_count)))
                    else:
                        list_id.append(genome_id)
                        outfile.write(line)
                else:
                    outfile.write(line)
    os.remove(path_aligner_infile)
    os.rename(path_aligner_infile + '.tmp', path_aligner_infile)
    return (len(list_id))


def multiple_position_infile_maker(seq_name, seq, path_infile):
    os.makedirs(path_infile, exist_ok=True)
    name_infile = path_infile + '/multiple_position.fasta'
    if not Path(name_infile).is_file():
        with open(name_infile, 'w') as outfile:
            pass
    with open(name_infile, 'a') as outfile:
        outfile.write('>' + seq_name + '\n')
        outfile.write(', '.join(map(str, seq)) + '\n')


def main():
    args = parseArguments()

    # Preparation of the data for the pairwise global alignment
    data_path = args.data_path
    path_aligner_infile = args.aligner_infile_path
    path_aligner_outfile = args.aligner_outfile_path
    path_sequence_filter = args.sequence_filter_path
    method = args.method
    tail_head = args.tail_head
    data_type = args.data_type

    # delete previous mutliple infile
    if Path(path_aligner_infile + '/multiple.fasta').is_file():
        os.remove(path_aligner_infile + '/multiple.fasta')
    sequence_filter = []
    # prepare nucleotide multiple alignment
    if data_type == 'nuc':
        if path_sequence_filter != 'NA':
            with open(path_sequence_filter, 'r') as infile:
                for line in infile:
                    sequence_filter.append(line.rstrip())
        for fasta_file in os.listdir(data_path):
            if os.path.splitext(fasta_file)[1] == '.fa' or os.path.splitext(fasta_file)[1] == '.fasta' and not fasta_file.startswith('._'):
                accession = os.path.splitext(os.path.basename(fasta_file))[0]
                if sequence_filter and accession in sequence_filter:
                    multiple_nuc_alignment_infile_maker(data_path + '/' + fasta_file, path_aligner_infile, tail_head)
                elif not sequence_filter:
                    multiple_nuc_alignment_infile_maker(data_path + '/' + fasta_file, path_aligner_infile, tail_head)

    #  prepare aa multiple alignment
    if data_type == 'aa':
        # delete previous position mutliple infile
        if Path(path_aligner_infile + '/multiple_position.fasta').is_file():
            os.remove(path_aligner_infile + '/multiple_position.fasta')

        for files in os.listdir(data_path):
            if os.path.splitext(files)[1] == ".txt" and not files.startswith('._'):
                with open(data_path + '/' + files) as json_file:
                    annot = json.load(json_file)
                    seq_pos = []
                    seq_aa = ''
                    for cds in sorted(annot['cds'], key=lambda x: int(annot['cds'][x]['start'])):
                        new_pos = list(range(annot['cds'][cds]['start'], annot['cds'][cds]['end']))

                        # deal with the situation where a sub sequence of a join sequence is independently annotated ie 80% of the position of the current annotation were already retrieve
                        pos_count = sum((1 for x in new_pos if x in seq_pos))
                        if (pos_count / len(new_pos)) >= 0.8:
                            continue

                        if annot['cds'][cds]['start'] in seq_pos:
                            seq_pos = seq_pos[:-3]
                            seq_aa = seq_aa[:-1]
                        new_seq_aa = annot['cds'][cds]['aa_seq'].rstrip()
                        if len(new_pos) % 3 != 0:
                            new_pos = new_pos[0:-(len(new_pos) % 3)]
                            new_seq_aa = new_seq_aa[0:-1]
                        if len(new_seq_aa) < (len(new_pos) / 3.0):
                            # new_seq_aa = new_seq_aa + '*'
                            new_pos = new_pos[0:-3]
                        seq_pos = seq_pos + new_pos
                        seq_aa = seq_aa + new_seq_aa
                    if (len(seq_pos) / 3) == len(seq_aa):
                        multiple_aa_alignment_infile_maker(os.path.splitext(os.path.basename(files))[0], seq_aa, path_aligner_infile, tail_head)
                        multiple_position_infile_maker(os.path.splitext(os.path.basename(files))[0], seq_pos, path_aligner_infile)
                    else:
                        print(files, len(seq_pos) / 3, len(seq_aa))
                        sys.exit("Pb for :" + path_aligner_outfile + '/' + files)

    nb_seq = check_mutliple_aligner_infile(path_aligner_infile + '/multiple.fasta')

    if sequence_filter and nb_seq != len(sequence_filter):
        sys.exit(str(len(sequence_filter)) + ' != ' + str(
            nb_seq) + ' Incorrect number of sequence in the infile fasta alignment')

    os.makedirs(path_aligner_outfile, exist_ok=True)



if __name__ == "__main__":
    main()
