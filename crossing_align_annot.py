import os
import sys
import argparse
import json


def parseArguments():
    # Create argument parser
    parser = argparse.ArgumentParser(
        description='command line example: python crossing_align_annot.py ~/Documents/SARS-cov2/table/mafft/SARS-cov2-vs-nr_multiple_1_gl3/outfile_mafft/ ~/Documents/SARS-cov2/table/cds/SARS-cov2-vs-nr_1_gl3_236-38/ ~/Documents/SARS-cov2/table/cds/SARS-cov2-vs-nr_1_gl3_236-38_mafft_aligned/')

    # Positional mandatory arguments
    parser.add_argument('-i', '--alignment_path',
                        help='absolute or relative path to the alignment outfile directory (generated by aligner.py)',
                        type=str)
    parser.add_argument('-c', '--path_cds',
                        help='absolute or relative path to the cds directory (generated by gbk_parsing.py)',
                        type=str)
    parser.add_argument('-o', '--path_aligned_cds',
                        help='absolute or relative path to the aligned cds directory (created)',
                        type=str)

    # Print version
    parser.add_argument("--version", action="version", version='%(prog)s - Version 2.00 - 14/10/2021')

    # Parse arguments
    args = parser.parse_args()

    return args


def multiple_alignment_loading(path_alignment_file):
    """
  From a raw alignment file (clustal format) return the align in a dictionary
  """

    path_infile = ''
    if os.path.isdir(path_alignment_file):
        for alignement_file in os.listdir(path_alignment_file):
            if os.path.splitext(alignement_file)[1] == ".aln" and not alignement_file.startswith('._'):
                path_infile = path_alignment_file + '/' + alignement_file
                break
    elif os.path.isfile(path_alignment_file):
        if os.path.splitext(path_alignment_file)[1] == ".aln" and not path_alignment_file.startswith('._'):
            path_infile = path_alignment_file
    if not path_infile:
        sys.exit("Invalid path to a .aln file")
    with open(path_alignment_file + '/' + alignement_file, 'r') as infile:
        al = {}
        for line in infile:
            handler = line.rstrip().split()
            # check for the first line of the file: do nothing
            if line.startswith('CLUSTAL'):
                continue
            # line not empty, retrieve alignement, skip identity line (* or . character in it)
            elif len(handler) == 2 and ('*' not in line):
                # Handle particular case with a . in the identity line with MAFFT
                if handler[0] not in al and '.' in handler[1]:
                    continue
                if handler[0] not in al:
                    al[handler[0]] = []
                al[handler[0]].extend(handler[1].lower())
    return al


def cross_alignment(path_cds_file, al, virus):
    """
  From a cds file, an alignment and a a reference, return an aligned cds annotation
  """
    all_new_cds = {'cds': {}}
    with open(path_cds_file, 'r') as infile:
        annot = json.load(infile)
        all_new_cds['complete_sequence'] = ''.join(al[virus]).upper()
        for cds in annot['cds']:
            start = annot['cds'][cds]['start']
            end = annot['cds'][cds]['end']
            raw_seq = annot['complete_sequence'][start: end].upper()
            match = False
            nb_match = 0
            new_seq = []
            al_start = 0
            index_seq = 0
            full_match = False
            al[virus] = ''.join(al[virus]).upper()
            index_al = 0
            while index_al < len(al[virus]):
                # nucleotide identity (match)
                if al[virus][index_al] == raw_seq[index_seq]:
                    if not match:
                        match = True
                        start_index = index_al
                        new_start = index_al
                    match = True
                    nb_match += 1
                    new_seq.append(al[virus][index_al])
                    index_seq += 1
                # gap
                elif match and al[virus][index_al] == '-':
                    new_seq.append(al[virus][index_al])
                #  mismatch
                else:
                    nb_match = 0
                    new_seq = []
                    index_seq = 0
                    if match:
                        match = False
                        continue
                    match = False
                # test if sequence fully retrieve
                if nb_match == len(raw_seq):
                    new_end = index_al
                    new_seq = ''.join(new_seq)
                    if cds not in all_new_cds:
                        all_new_cds['cds'][cds] = {}
                        all_new_cds['cds'][cds]['start'] = new_start
                        all_new_cds['cds'][cds]['end'] = index_al
                        all_new_cds['cds'][cds]['seq'] = new_seq.upper()
                        all_new_cds['cds'][cds]['aa_seq'] = annot['cds'][cds]['aa_seq']
                        full_match = True
                    else:
                        sys.exit(cds + " already exist, unanticiped case")
                    break
                index_al += 1
            if not full_match:
                sys.exit(cds + " not aligned, unanticiped case")
    return all_new_cds


def main():
    args = parseArguments()
    path_alignment_file = args.alignment_path
    path_cds = args.path_cds
    path_aligned_cds = args.path_aligned_cds

    # alignment file loading
    al = multiple_alignment_loading(path_alignment_file)

    os.makedirs(path_aligned_cds, exist_ok=True)

    # virus annotation extraction
    for virus in al:
        # print(virus)
        for cds_file in os.listdir(path_cds):
            if virus in cds_file and os.path.splitext(cds_file)[1] == ".txt" and not cds_file.startswith('._'):
                all_new_cds = cross_alignment(path_cds + '/' + cds_file, al, virus)
                with open(path_aligned_cds + '/' + os.path.splitext(os.path.basename(cds_file))[0] + '.cross',
                          'w') as outfile:
                    json.dump(all_new_cds, outfile)
                ###
                # format alignement construction
                al_fmt = {}  # handler for the formated alignement
                # browse all position
                for i, nuc in enumerate(all_new_cds['complete_sequence']):
                    if i not in al_fmt:
                        al_fmt[i] = {}
                    else:
                        sys.exit(str(i) + ' already in al_fmt')
                    # find if coding region containing i:
                    list_coding_region = []
                    for cds_id in all_new_cds['cds']:
                        if int(i) >= int(all_new_cds['cds'][cds_id]['start']) and int(i) <= int(
                                all_new_cds['cds'][cds_id]['end']):
                            list_coding_region.append(cds_id)
                    # i is in a coding region
                    if list_coding_region:
                        al_fmt[i]['coding'] = True
                        for cds_id in list_coding_region:
                            # add cds id key if not in the dict (first encounter)
                            if not cds_id in al_fmt[i]:
                                al_fmt[i][cds_id] = {}
                            al_fmt[i][cds_id]['nuc'] = nuc
                            # position corresponding to a gap
                            if nuc == '-':
                                continue
                            # position is not a gap
                            else:
                                # nb gap before i in this coding region
                                nb_prev_gap = len(
                                    [x for x in al_fmt if cds_id in al_fmt[x] and al_fmt[x][cds_id]['nuc'] == '-'])
                                # find corresponding codon
                                codon = (int(i) - int(all_new_cds['cds'][cds_id]['start']) - nb_prev_gap) // 3
                                # find the position in the codon
                                pos_codon = (int(i) - int(all_new_cds['cds'][cds_id]['start']) - nb_prev_gap) % 3
                                # find the corresponding aa
                                # if stop codon
                                if codon == len(all_new_cds['cds'][cds_id]['aa_seq']):
                                    aa = "*"
                                else:
                                    # print(cds_id)
                                    # print(codon)
                                    # print(all_new_cds['cds'][cds_id])
                                    aa = all_new_cds['cds'][cds_id]['aa_seq'][codon]
                                al_fmt[i][cds_id]['codon'] = codon
                                al_fmt[i][cds_id]['pos_codon'] = pos_codon
                                al_fmt[i][cds_id]['aa'] = aa
                    # i is not in a coding region
                    else:
                        if not 'coding' in al_fmt[i]:
                            al_fmt[i]['coding'] = False
                with open(path_aligned_cds + '/' + os.path.splitext(os.path.basename(cds_file))[0] + '_codon.cross',
                          'w') as outfile:
                    json.dump(al_fmt, outfile)


if __name__ == "__main__":
    main()